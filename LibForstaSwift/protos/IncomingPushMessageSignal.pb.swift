// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: IncomingPushMessageSignal.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Signal_Envelope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Signal_Envelope.TypeEnum {
    get {return _type ?? .unknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var source: String {
    get {return _source ?? String()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var sourceDevice: UInt32 {
    get {return _sourceDevice ?? 0}
    set {_sourceDevice = newValue}
  }
  /// Returns true if `sourceDevice` has been explicitly set.
  var hasSourceDevice: Bool {return self._sourceDevice != nil}
  /// Clears the value of `sourceDevice`. Subsequent reads from it will return its default value.
  mutating func clearSourceDevice() {self._sourceDevice = nil}

  var relay: String {
    get {return _relay ?? String()}
    set {_relay = newValue}
  }
  /// Returns true if `relay` has been explicitly set.
  var hasRelay: Bool {return self._relay != nil}
  /// Clears the value of `relay`. Subsequent reads from it will return its default value.
  mutating func clearRelay() {self._relay = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// Contains an encrypted DataMessage
  var legacyMessage: Data {
    get {return _legacyMessage ?? SwiftProtobuf.Internal.emptyData}
    set {_legacyMessage = newValue}
  }
  /// Returns true if `legacyMessage` has been explicitly set.
  var hasLegacyMessage: Bool {return self._legacyMessage != nil}
  /// Clears the value of `legacyMessage`. Subsequent reads from it will return its default value.
  mutating func clearLegacyMessage() {self._legacyMessage = nil}

  /// Contains an encrypted Content
  var content: Data {
    get {return _content ?? SwiftProtobuf.Internal.emptyData}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  /// How long the message was stored on the server.
  var age: UInt64 {
    get {return _age ?? 0}
    set {_age = newValue}
  }
  /// Returns true if `age` has been explicitly set.
  var hasAge: Bool {return self._age != nil}
  /// Clears the value of `age`. Subsequent reads from it will return its default value.
  mutating func clearAge() {self._age = nil}

  /// Server added timestamp of when message came in.
  var received: UInt64 {
    get {return _received ?? 0}
    set {_received = newValue}
  }
  /// Returns true if `received` has been explicitly set.
  var hasReceived: Bool {return self._received != nil}
  /// Clears the value of `received`. Subsequent reads from it will return its default value.
  mutating func clearReceived() {self._received = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case ciphertext // = 1
    case keyExchange // = 2
    case prekeyBundle // = 3
    case receipt // = 5

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ciphertext
      case 2: self = .keyExchange
      case 3: self = .prekeyBundle
      case 5: self = .receipt
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ciphertext: return 1
      case .keyExchange: return 2
      case .prekeyBundle: return 3
      case .receipt: return 5
      }
    }

  }

  init() {}

  fileprivate var _type: Signal_Envelope.TypeEnum? = nil
  fileprivate var _source: String? = nil
  fileprivate var _sourceDevice: UInt32? = nil
  fileprivate var _relay: String? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _legacyMessage: Data? = nil
  fileprivate var _content: Data? = nil
  fileprivate var _age: UInt64? = nil
  fileprivate var _received: UInt64? = nil
}

#if swift(>=4.2)

extension Signal_Envelope.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Signal_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dataMessage: Signal_DataMessage {
    get {return _storage._dataMessage ?? Signal_DataMessage()}
    set {_uniqueStorage()._dataMessage = newValue}
  }
  /// Returns true if `dataMessage` has been explicitly set.
  var hasDataMessage: Bool {return _storage._dataMessage != nil}
  /// Clears the value of `dataMessage`. Subsequent reads from it will return its default value.
  mutating func clearDataMessage() {_uniqueStorage()._dataMessage = nil}

  var syncMessage: Signal_SyncMessage {
    get {return _storage._syncMessage ?? Signal_SyncMessage()}
    set {_uniqueStorage()._syncMessage = newValue}
  }
  /// Returns true if `syncMessage` has been explicitly set.
  var hasSyncMessage: Bool {return _storage._syncMessage != nil}
  /// Clears the value of `syncMessage`. Subsequent reads from it will return its default value.
  mutating func clearSyncMessage() {_uniqueStorage()._syncMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Signal_DataMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var body: String {
    get {return _body ?? String()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {self._body = nil}

  var attachments: [Signal_AttachmentPointer] = []

  var flags: UInt32 {
    get {return _flags ?? 0}
    set {_flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return self._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {self._flags = nil}

  var expireTimer: UInt32 {
    get {return _expireTimer ?? 0}
    set {_expireTimer = newValue}
  }
  /// Returns true if `expireTimer` has been explicitly set.
  var hasExpireTimer: Bool {return self._expireTimer != nil}
  /// Clears the value of `expireTimer`. Subsequent reads from it will return its default value.
  mutating func clearExpireTimer() {self._expireTimer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Flags: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case endSession // = 1
    case expirationTimerUpdate // = 2

    init() {
      self = .endSession
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .endSession
      case 2: self = .expirationTimerUpdate
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .endSession: return 1
      case .expirationTimerUpdate: return 2
      }
    }

  }

  init() {}

  fileprivate var _body: String? = nil
  fileprivate var _flags: UInt32? = nil
  fileprivate var _expireTimer: UInt32? = nil
}

#if swift(>=4.2)

extension Signal_DataMessage.Flags: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Signal_SyncMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sent: Signal_SyncMessage.Sent {
    get {return _storage._sent ?? Signal_SyncMessage.Sent()}
    set {_uniqueStorage()._sent = newValue}
  }
  /// Returns true if `sent` has been explicitly set.
  var hasSent: Bool {return _storage._sent != nil}
  /// Clears the value of `sent`. Subsequent reads from it will return its default value.
  mutating func clearSent() {_uniqueStorage()._sent = nil}

  var contacts: Signal_SyncMessage.Contacts {
    get {return _storage._contacts ?? Signal_SyncMessage.Contacts()}
    set {_uniqueStorage()._contacts = newValue}
  }
  /// Returns true if `contacts` has been explicitly set.
  var hasContacts: Bool {return _storage._contacts != nil}
  /// Clears the value of `contacts`. Subsequent reads from it will return its default value.
  mutating func clearContacts() {_uniqueStorage()._contacts = nil}

  var groups: Signal_SyncMessage.Groups {
    get {return _storage._groups ?? Signal_SyncMessage.Groups()}
    set {_uniqueStorage()._groups = newValue}
  }
  /// Returns true if `groups` has been explicitly set.
  var hasGroups: Bool {return _storage._groups != nil}
  /// Clears the value of `groups`. Subsequent reads from it will return its default value.
  mutating func clearGroups() {_uniqueStorage()._groups = nil}

  var request: Signal_SyncMessage.Request {
    get {return _storage._request ?? Signal_SyncMessage.Request()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {_uniqueStorage()._request = nil}

  var read: [Signal_SyncMessage.Read] {
    get {return _storage._read}
    set {_uniqueStorage()._read = newValue}
  }

  var blocked: Signal_SyncMessage.Blocked {
    get {return _storage._blocked ?? Signal_SyncMessage.Blocked()}
    set {_uniqueStorage()._blocked = newValue}
  }
  /// Returns true if `blocked` has been explicitly set.
  var hasBlocked: Bool {return _storage._blocked != nil}
  /// Clears the value of `blocked`. Subsequent reads from it will return its default value.
  mutating func clearBlocked() {_uniqueStorage()._blocked = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Sent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var destination: String {
      get {return _storage._destination ?? String()}
      set {_uniqueStorage()._destination = newValue}
    }
    /// Returns true if `destination` has been explicitly set.
    var hasDestination: Bool {return _storage._destination != nil}
    /// Clears the value of `destination`. Subsequent reads from it will return its default value.
    mutating func clearDestination() {_uniqueStorage()._destination = nil}

    var timestamp: UInt64 {
      get {return _storage._timestamp ?? 0}
      set {_uniqueStorage()._timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return _storage._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

    var message: Signal_DataMessage {
      get {return _storage._message ?? Signal_DataMessage()}
      set {_uniqueStorage()._message = newValue}
    }
    /// Returns true if `message` has been explicitly set.
    var hasMessage: Bool {return _storage._message != nil}
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating func clearMessage() {_uniqueStorage()._message = nil}

    var expirationStartTimestamp: UInt64 {
      get {return _storage._expirationStartTimestamp ?? 0}
      set {_uniqueStorage()._expirationStartTimestamp = newValue}
    }
    /// Returns true if `expirationStartTimestamp` has been explicitly set.
    var hasExpirationStartTimestamp: Bool {return _storage._expirationStartTimestamp != nil}
    /// Clears the value of `expirationStartTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearExpirationStartTimestamp() {_uniqueStorage()._expirationStartTimestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Contacts {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var blob: Signal_AttachmentPointer {
      get {return _storage._blob ?? Signal_AttachmentPointer()}
      set {_uniqueStorage()._blob = newValue}
    }
    /// Returns true if `blob` has been explicitly set.
    var hasBlob: Bool {return _storage._blob != nil}
    /// Clears the value of `blob`. Subsequent reads from it will return its default value.
    mutating func clearBlob() {_uniqueStorage()._blob = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Groups {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var blob: Signal_AttachmentPointer {
      get {return _storage._blob ?? Signal_AttachmentPointer()}
      set {_uniqueStorage()._blob = newValue}
    }
    /// Returns true if `blob` has been explicitly set.
    var hasBlob: Bool {return _storage._blob != nil}
    /// Clears the value of `blob`. Subsequent reads from it will return its default value.
    mutating func clearBlob() {_uniqueStorage()._blob = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Blocked {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var addrs: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Signal_SyncMessage.Request.TypeEnum {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case contacts // = 1
      case groups // = 2
      case blocked // = 3

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .contacts
        case 2: self = .groups
        case 3: self = .blocked
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contacts: return 1
        case .groups: return 2
        case .blocked: return 3
        }
      }

    }

    init() {}

    fileprivate var _type: Signal_SyncMessage.Request.TypeEnum? = nil
  }

  struct Read {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sender: String {
      get {return _sender ?? String()}
      set {_sender = newValue}
    }
    /// Returns true if `sender` has been explicitly set.
    var hasSender: Bool {return self._sender != nil}
    /// Clears the value of `sender`. Subsequent reads from it will return its default value.
    mutating func clearSender() {self._sender = nil}

    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sender: String? = nil
    fileprivate var _timestamp: UInt64? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Signal_AttachmentPointer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var contentType: String {
    get {return _contentType ?? String()}
    set {_contentType = newValue}
  }
  /// Returns true if `contentType` has been explicitly set.
  var hasContentType: Bool {return self._contentType != nil}
  /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
  mutating func clearContentType() {self._contentType = nil}

  var key: Data {
    get {return _key ?? SwiftProtobuf.Internal.emptyData}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: UInt64? = nil
  fileprivate var _contentType: String? = nil
  fileprivate var _key: Data? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "signal"

extension Signal_Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Envelope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "source"),
    7: .same(proto: "sourceDevice"),
    3: .same(proto: "relay"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "legacyMessage"),
    8: .same(proto: "content"),
    9: .same(proto: "age"),
    10: .same(proto: "received"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._type)
      case 2: try decoder.decodeSingularStringField(value: &self._source)
      case 3: try decoder.decodeSingularStringField(value: &self._relay)
      case 5: try decoder.decodeSingularUInt64Field(value: &self._timestamp)
      case 6: try decoder.decodeSingularBytesField(value: &self._legacyMessage)
      case 7: try decoder.decodeSingularUInt32Field(value: &self._sourceDevice)
      case 8: try decoder.decodeSingularBytesField(value: &self._content)
      case 9: try decoder.decodeSingularUInt64Field(value: &self._age)
      case 10: try decoder.decodeSingularUInt64Field(value: &self._received)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._relay {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._legacyMessage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }
    if let v = self._sourceDevice {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._content {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }
    if let v = self._age {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
    }
    if let v = self._received {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_Envelope, rhs: Signal_Envelope) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._source != rhs._source {return false}
    if lhs._sourceDevice != rhs._sourceDevice {return false}
    if lhs._relay != rhs._relay {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._legacyMessage != rhs._legacyMessage {return false}
    if lhs._content != rhs._content {return false}
    if lhs._age != rhs._age {return false}
    if lhs._received != rhs._received {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_Envelope.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CIPHERTEXT"),
    2: .same(proto: "KEY_EXCHANGE"),
    3: .same(proto: "PREKEY_BUNDLE"),
    5: .same(proto: "RECEIPT"),
  ]
}

extension Signal_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Content"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataMessage"),
    2: .same(proto: "syncMessage"),
  ]

  fileprivate class _StorageClass {
    var _dataMessage: Signal_DataMessage? = nil
    var _syncMessage: Signal_SyncMessage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dataMessage = source._dataMessage
      _syncMessage = source._syncMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._dataMessage)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._syncMessage)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._dataMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._syncMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_Content, rhs: Signal_Content) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dataMessage != rhs_storage._dataMessage {return false}
        if _storage._syncMessage != rhs_storage._syncMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "attachments"),
    4: .same(proto: "flags"),
    5: .same(proto: "expireTimer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._body)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.attachments)
      case 4: try decoder.decodeSingularUInt32Field(value: &self._flags)
      case 5: try decoder.decodeSingularUInt32Field(value: &self._expireTimer)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._body {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 2)
    }
    if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._expireTimer {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_DataMessage, rhs: Signal_DataMessage) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs._expireTimer != rhs._expireTimer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_DataMessage.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "END_SESSION"),
    2: .same(proto: "EXPIRATION_TIMER_UPDATE"),
  ]
}

extension Signal_SyncMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sent"),
    2: .same(proto: "contacts"),
    3: .same(proto: "groups"),
    4: .same(proto: "request"),
    5: .same(proto: "read"),
    6: .same(proto: "blocked"),
  ]

  fileprivate class _StorageClass {
    var _sent: Signal_SyncMessage.Sent? = nil
    var _contacts: Signal_SyncMessage.Contacts? = nil
    var _groups: Signal_SyncMessage.Groups? = nil
    var _request: Signal_SyncMessage.Request? = nil
    var _read: [Signal_SyncMessage.Read] = []
    var _blocked: Signal_SyncMessage.Blocked? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sent = source._sent
      _contacts = source._contacts
      _groups = source._groups
      _request = source._request
      _read = source._read
      _blocked = source._blocked
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._sent)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._contacts)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._groups)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._request)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._read)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._blocked)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._contacts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._groups {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._read.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._read, fieldNumber: 5)
      }
      if let v = _storage._blocked {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SyncMessage, rhs: Signal_SyncMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sent != rhs_storage._sent {return false}
        if _storage._contacts != rhs_storage._contacts {return false}
        if _storage._groups != rhs_storage._groups {return false}
        if _storage._request != rhs_storage._request {return false}
        if _storage._read != rhs_storage._read {return false}
        if _storage._blocked != rhs_storage._blocked {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SyncMessage.Sent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SyncMessage.protoMessageName + ".Sent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "message"),
    4: .same(proto: "expirationStartTimestamp"),
  ]

  fileprivate class _StorageClass {
    var _destination: String? = nil
    var _timestamp: UInt64? = nil
    var _message: Signal_DataMessage? = nil
    var _expirationStartTimestamp: UInt64? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _destination = source._destination
      _timestamp = source._timestamp
      _message = source._message
      _expirationStartTimestamp = source._expirationStartTimestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._destination)
        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._timestamp)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._message)
        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._expirationStartTimestamp)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._destination {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._expirationStartTimestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SyncMessage.Sent, rhs: Signal_SyncMessage.Sent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._destination != rhs_storage._destination {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._expirationStartTimestamp != rhs_storage._expirationStartTimestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SyncMessage.Contacts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SyncMessage.protoMessageName + ".Contacts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blob"),
  ]

  fileprivate class _StorageClass {
    var _blob: Signal_AttachmentPointer? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _blob = source._blob
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._blob)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._blob {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SyncMessage.Contacts, rhs: Signal_SyncMessage.Contacts) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._blob != rhs_storage._blob {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SyncMessage.Groups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SyncMessage.protoMessageName + ".Groups"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blob"),
  ]

  fileprivate class _StorageClass {
    var _blob: Signal_AttachmentPointer? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _blob = source._blob
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._blob)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._blob {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SyncMessage.Groups, rhs: Signal_SyncMessage.Groups) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._blob != rhs_storage._blob {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SyncMessage.Blocked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SyncMessage.protoMessageName + ".Blocked"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addrs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.addrs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addrs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addrs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SyncMessage.Blocked, rhs: Signal_SyncMessage.Blocked) -> Bool {
    if lhs.addrs != rhs.addrs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SyncMessage.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SyncMessage.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SyncMessage.Request, rhs: Signal_SyncMessage.Request) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SyncMessage.Request.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTACTS"),
    2: .same(proto: "GROUPS"),
    3: .same(proto: "BLOCKED"),
  ]
}

extension Signal_SyncMessage.Read: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SyncMessage.protoMessageName + ".Read"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._sender)
      case 2: try decoder.decodeSingularUInt64Field(value: &self._timestamp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sender {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SyncMessage.Read, rhs: Signal_SyncMessage.Read) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_AttachmentPointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttachmentPointer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "contentType"),
    3: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFixed64Field(value: &self._id)
      case 2: try decoder.decodeSingularStringField(value: &self._contentType)
      case 3: try decoder.decodeSingularBytesField(value: &self._key)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_AttachmentPointer, rhs: Signal_AttachmentPointer) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._contentType != rhs._contentType {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
